{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start二级标题测试Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment /image (6).png)","link":"/2020/03/01/hello-world/"},{"title":"超级详细Hexo+GitHub+阿里云域名的博客搭建教程","text":"​ 摸索了挺长时间建网站建博客等东西，最初我是从买阿里云服务器和域名开始了解这些的，也用宝塔搭过网站，觉得这些东西还挺有意思的，最开始我用过宝塔的一键部署wordpress博客，感觉挺爽，拥有的自己的博客，但直到我知道有Hexo这种静态博客框架后我才明白这才是真正的搭建博客。 ​ 下面就来让我分享一下我这一段时间摸索出来的皮毛经验——关于搭建Hexo静态博客 ​ 跟着我一步一步来做，你马上就有自己的博客啦！ 开始 一，首先安装前提软件环境 node.js 和 Git ​ 安装软件比较简单，正常安装就行，我就不多赘述，下面是安装地址，不懂得可以看看别的博主的的教程。 ​ node.j安装地址: https://nodejs.org/zh-cn/ ​ node.js安装教程:https://blog.csdn.net/qq_42543312/article/details/82191357 ​ Git安装地址:https://git-scm.com/ Git安装教程:https://www.cnblogs.com/xueweisuoyong/archive/2019/11/22/11914045.html ​ 安装完成我们可以在桌面右键，点击Git Bash Here ，分别输入以下命令，如果出现对应版本的信息，证明我们的node.js和Git安装正常可用，另外说一下 其实npm是nodejs的包管理器（package manager），能解决node.js代码部署上的很多问题,我们在安装时用到的都是npm命令。npm -v证明我们的包管理器也安装成功。 123git versionnode -vnpm -v 二，安装Hexo以上步骤成功后就可以进行Hexo的安装了，用npm 安装 Hexo，输入以下命令 1npm install hexo-cli -g 以上表示hexo安装成功，hexo默认会被安装到C盘这个不用管 三，本地搭建Hexo 下一步选择一个本地目录开始创建博客 输入以下命令，注意：blog是你在当前目录下进行hexo安装的文件夹，随便叫什么你自己起名，这个文件夹会自动生成。 1hexo init blog 输入完命令后我们可以看到自己刚才进入的本地目录下创建了一个“blog”文件夹，这就是hexo的本地博客文件 此时我们继续输入下一条命令：此命令用来补充一些hexo博客的依赖 1hexo install 到此为止我们的hexo博客本地文件就准备好了 下一步我们开启hexo本地服务,启动服务器 123$ hexo server#或者可以简写为$ hexo s hexo服务默认开放4000端口，现在快打开浏览器访问http://localhost:4000就可以看到你的博客啦！ 是不是感觉wc ，wfk ！ 好神奇啊，啊哈哈哈哈！ 四，GitHub部署Hexo 既然在github上部署博客，首先你的有一个自己的github账号 github官网: https://github.com/ 正常注册即可，然后在这里点击新建一个仓库. 这里注意，仓库名格式一定要为 你的用户名.github.io （注意是注册时的用户名而不是昵称） 这里非常重要，例如注册用户名为：xiaoming ，那仓库名一定要设置为 xiaoming.github.io ，接着点击Create Repository 接着我们回到命令行，输入以下命令，在git终端分别配置自己的用户名和邮箱。命令如下:12git config --global user.name XXX # XXX表示你github注册时的用户名git config --global user.email XXX # XXX表示你github注册时的邮箱 接着输入以下命令生成密钥：12ssh-keygen -t rsa -C &quot;Github上你注册的邮箱地址&quot; 冒号后边就输入空格，y/n 输入y 接着我们在该目录下能找到id_rsa.pub,这里存储的就是我们的密钥，打开复制所有内容 然后我们回到GitHub 点击Setting —&gt; SSH and GPG keys —&gt; New SSHkey 将密钥复制到文本框内 ，保存 ， Tittle随便起。 接着到了很关键的一步是我们要到刚才本地部署博客文件根目录下去修改一下_config.yml配置文件: 我用的编辑器是VScode ，其他的都可以，不影响，打开后我们会看到密密麻麻的配置信息，不用慌，我们只需要在配置信息的最下方改成如下配置 12345678deploy: type: 'git' repo: https://github.com/yourname/yourname.github.io.git branch: master#需要注意的是：#1、冒号后面一定要有一个空格#2、type，repository，branch的首字母要对齐 至于仓库地址怎么找，如果不会我再多啰嗦一下，会的就跳过吧 复制地址，注意选HTTP地址 或者SSH地址都可以 最后我们开始部署输入以下命令行： 123456789101112#要安装一个部署插件hexo-deployer-git。npm install hexo-deployer-git --save#生成静态文件g 是 generate 缩写hexo g#部署，d 是 deploy 缩写：hexo d#或者将二、三句结合为hexo g -d 第一次部署需要输入github用户名和密码 此时我们可以看到在我们的仓库中多出了很多文件 以上过程证明我们在GitHub部署成功，我们直接何以通过github地址访问了 ​ https://1819597376.github.io/ ​ 到此你就拥有你自己的个人网络博客了，兴奋吗铁子？ 五，绑定域名1，购买域名​ 首先你需要拥有自己的域名，这里先把域名做一下解释 ​ 域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。 ​ 简单多就是因为github的地址太长或服务器的公网IP全数字不好记，我们需要一个好记的地址也就这我们的需要的域名来与自己的github仓库地址来做一个捆绑，通过这个好记的域名来访问我们的网站或者博客，比如我们要访问百度时在浏览器地址栏直接搜做 baidu.com 就可访问百度网页而不是输入长长的IP地址。这种绑定关系会存储在DNS中，即域名系统（服务）协议。 ​ 这也是我们要做域名绑定的目的，购买就不多赘述，因为我的域名是阿里云购买，这里我仅以阿里云平台的域名进行介绍，如果想买其他平台的域名也可以，我们的操作流程大同小异，不会就看下面这个购买教程 域名购买教程 : https://www.jianshu.com/p/e11a136ebd02 2，域名解析​ 拥有域名后，我要对域名进行解析操作来实现域名和我们仓库地址的绑定。 ​ 我们要添加两条记录 ​ 保存后得到这两条记录即可： 接下来回到github仓库，创建一个名为CNAME的文件，内容为你的域名： ​ 就在此刻奇迹发生了 就这样了，完美结束，写的我好累啊哈哈哈，感谢使用此教程，也为你成功搭建Hexo博客而感到高兴！ ​ 我的博客： trouble.com 最后寄语​ 没有人天生什么都会 ​ 不说所有人都是天才 ​ 如果你不是 ​ 就请停止幻想 脚踏实地吧 ​ 学 IT就不要害怕犯错 错误越多越好 ​ 再见","link":"/2020/03/10/%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86Hexo-GitHub-%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"title":"test2","text":"","link":"/2020/03/10/node.js&Git/"},{"title":"一个“.java”文件中是否可以包含多个类（这里不内部类不算），有什么限制？","text":"一个“.java”文件中是否可以包含多个类（这里不内部类不算），有什么限制？*答案：可以包含多个类，但是只能由一个public类 * ​ java文件中完全可以有多个类，我指的是即使不算内部类这一说，也可以定义有多个类，但是有一点限制就是一个“.java”文件中只能有一个被public修饰的公共类，仅有一个，这样设计的意义是基于面向对象思想的基础上，我们能保证一个类只有一个公开接口。一个“.java”文件也就是一个Java程序被称为一个编译单元，如果文件中有多个public权限的类则编译器将不知道从哪里进入，因而报错。 ​ 那么其他非public类有什么用吗其实我们的public类就像是一个团队的老大且实门面担当，而其他类就是在他背后默默付出却不被人所知的小弟们，意思是，内部类在包外是不能被看见的（不能被调用），他的作用就是为public类提供支持。","link":"/2020/03/13/%E4%B8%80%E4%B8%AA%E2%80%9C-java%E2%80%9D%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%B1%BB%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8D%E7%AE%97%EF%BC%89%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F/"},{"title":"java的8种数据类型","text":"java数据类型一共有四类八种： 序号 大类 数据类型 字节/位数 默认值 取值范围 举例说明 1 整型 byte（位） 1/8 0 -2^7 - 2^7-1(-128-127) byte b = 100； 2 整型 short（短整型） 2/16 0 -2^15 - 2^15-1(-32768-32767） short s=100； 3 整型 int（整数） 4/32 0 -2^31 - 2^31-1 int i = 100 4 整型 long（长整型） 8/64 0 -2^63 - 2 ^63-1 long l = 100l； 5 浮点型 float（单精度） 4/32 0.0 -2^31 - 2^31-1 float f = 100.0f 6 浮点型 double（双精度） 8/64 0.0 -2^63-2^63-1 double d = 100.0d; 7 字符型 char（字符） 16 0-2^16-1 char = ‘c ‘; 8 布尔型 boolean（布尔值） 8 false true 、false boolean = true；","link":"/2020/03/14/java%E7%9A%848%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Java面向对象的特征","text":"面试官：Java面向对象的特征是社什么？ 你：封装、继承、抽象、多态 面试官：。。。 这个回答好像大家都能说出来，多说点，用你自己的理解说出来： 1.封装封装就是把客观事物进行抽象封装，隐藏一些可隐藏的东西，指向外界提供一个最简单的的接口。 把描述对象的属性和行为封装在一个模块中，也就是一个类中，属性用变量定义，行为用方法定义，方法可以直接访问同一个对象之间的属性。 2.抽象把现实生活中的对象抽象为类，分过程抽象的数据抽象 数据抽象 ： 鸟有翅膀、羽毛等（类的属性） 过程抽象 ： 鸟会飞（类的方法） 3.继承子类继承父类的特征和行为，也就是属和方法，并且可以重写父类的方法，也可以自己进行扩展，新增加属性 和方法。 举例：水果（父类） 苹果（子类） 香蕉（子类） 4.多态多态是指允许不同子类型的对象对同一消息做出不同的响应， 系统可依据对象所属类别，引发对应类别的方法，而有不同的行为 优点：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。","link":"/2020/03/15/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81/"},{"title":"String、StringBuffer和StringBuilder的区别","text":"今天很大家来聊一下这个基础的问题 说他们三者之间的区别我总结为一下三点： 1.String长度不可变而StringBuffer和SringBuilder长度可变2.他们的运行速度不同 ：SringBuilder &gt; StringBuffer &gt; String3.SringBuilder 线程不安全 和 StringBuffer线程安全下面我来一个一个解释： 一.String长度不可变而StringBuffer和SringBuilder长度可变废话不多说，先上源码！ 如果你可以打开三个类的源码看一下你就明白了 我们能看到，String这个类底层使用了final修饰的长度不可变的字符数组，所以它长度不可变 1private final char value[]; 而StringBuffer和StringBuilder 都继承自AbstractStringBuilder ，且AbstractStringBuilder底层使用的是可变字符数组，所以二者长度可变。 1char[] value; 二.他们的运行速度不同 ：SringBuilder &gt; StringBuffer &gt; String先来看这样一段代码 12345678public class MainTest { public static void main(String[] args) { String str = \"abc\"; System.out.println(str); str = str + \"cd\"; System.out.println(str); }} 输出结果为： abc abcd ​ 整个程序运行完我们看似是str这个对象被更改了，在后面加上了一段新的字符，但这只是假象，因为我们刚才说过String类型的字符串长度是不可变的啊，其实JVM是先创建的了一个str对象，将“abc”赋值给str，然后在内存中又创建了第二个str对象，将第一个str对象中的“abc”与”de“相加再赋值给第二个str对象，此时Java虚拟机的垃圾回收机制开始其工作将第一个str对象回收。所以说String类型的字符串要完成这样”改变长度“的操作需要不断地创建再回收，创建再回收，无形中经过了很多步骤，而 StringBuffer和SringBuilder数组可变，直接可进行更改，所以要更快。 而SringBuilder 为什么比 StringBuffer 要快呢？ 先来看源码： ​ 从图中可以看出StringBuffer的append的方法都被toStringCache关键字修饰了（不止图中这两个append方法包括StringBuffer源码中所有append重载方法都被toStringCache修饰了。） toStringCache关键字是给线程加锁，枷锁是会带来性能上的损耗的，故用SringBuilder 比 StringBuffer 要快 锁不懂先没关系，往下看！暂且理解为什么快。 三.SringBuilder 线程不安全 和 StringBuffer线程安全​ 线程安全不同的问题要和刚才的的思路连起来，正是因为有了toStringCache关键字修饰StringBuffer的append方法有，给线程加了锁加了锁所以线程安全。 ​ 这样理解，如果一个StringBuffer对象的字符串在字符串缓冲区被多个线程同时使用时，也就是多个线程同时操作，这样会有出现错误操作的概率，为了保证线程的安全性，进行加锁，这样会使同一时间只有一个线程获得权限，其他线程必须等待该线程结束并释放锁才能获得权限，这样线程非常安全，虽然效率慢了点，但是当项目安全性要求很高时就必须用StringBuffer。单一线程下还是的用更快一点的SringBuilder 。","link":"/2020/03/16/String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"简单说一下java跨平台","text":"​ 简单理解：跨平台故名思意，其不受各种平台的限制，在多种平台上都能运行，及不依赖于操作系统有不依赖于硬件环境，一种操作系统下开发的应用到另一种操作系统下任可以运行； ​ 面试时应该这么说： 注意抓住关键两点术语：操作系统指令集、屏蔽系统之间的差异 ​ 由于各种操作系统之间的指令集不完全相同，所以在操作系统之上加个虚拟机可以来提供统一的接口，屏蔽系统之间的差异。","link":"/2020/03/14/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"title":"ArrayList源码分析-面试必会","text":"今天来说一说JAVA中我们比较熟悉的 ArrayList ，据说在面试中要你手写ArrayList都是有可能的，所以我i这两天读了ArrayList的源码，参考了一些资料，来把我的理解分享一下。 ArrayList 的特点 ArrayList底层是基于Object[] 数组来实现的， 是一个动态扩展数组 ，Object数组默认容量是10，当长度不够时会自动将容量扩展到其原来的1.5倍。自动增长会带来数据向新数组的拷贝。 ArrayList插入删除操作都是通过数据在数组中的移动实现的，所以增删效率底，而改查怎依然是通过数组下标直接定位，改查效率高。 ArrayList线程不同步，也就是线程不安全 ArayList是有序的，元素可重复的，允许元素为null值 ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。 源码分析下面进行源码分析，我知道有些小白看到源码就会有惧怕感，但没关系，在我逐一讲解的同时请你打开你的IDE进入到ArrayList的源码跟我一起看，你一定会感觉好多了。 一.属性分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{ private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. * 默认初始化容量为10 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 如果自定义容量为0，则会默认用他俩初始化ArrayList，或者用于空数组替换 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 如果没有定义容量则会用他来初始化ArrayList，或者用于空数组对比 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. * 这就是底层用到的数组，非私有，以简化嵌套类访问 * transient 在已经实现序列化的类中不允许某变量序列化 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * 实际ArrayList集合的大小 * @serial */ private int size; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 可分配的最大容量 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 二.构造方法分析用无参构造初始化，默认容量为10 123public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 构造一个初始容量为initialCapacity的空列表 如果传入的initialCapacity为负数则会抛IllegalArgumentException异常 12345678910public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 通过结合做参数的形式初始化 按照集合的迭代返回他们的顺序，C集合的元素将被放入列表 如果集合为空则初始化为空数组 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 三.主方法解析trimToSize()用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小，再底层的Copy方法实现了新数组的拷贝 12345678910111213/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); }} 123public static &lt;T&gt; T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass());} 123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;} public static Object newInstance(Class&lt;?&gt; componentType, int length) throws NegativeArraySizeException { return newArray(componentType, length); } clone()克隆出一个新数组，通过调用Object的clone()方法来得到一个新的ArrayList对象，然后将elementData复制给该对象并返回。 1234567891011121314151617/** * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance. (The * elements themselves are not copied.) * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() { try { ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(e); } } add(E e)再数组添加元素 数据尾部插入，由于不会影响其他元素，因此会直接插入到后面。 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} 看到它首先调用了ensureCapacityInternal()方法.注意参数是size+1,这是个面试考点。 该方法做了两件事：计算容量+确保容量 if语句进行计算容量，如果elementData是空，则返回默认容量10和size+1的最大值，否则返回size+1 1234567private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity);} 计算完容量后，进行确保容量可用：(modCount不用理它，它用来计算修改次数) 如果size+1 &gt; elementData.length证明数组已经放满，则增加容量，调用grow()。 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);} 增加容量：默认1.5倍扩容。 获取当前数组长度=&gt;oldCapacity oldCapacity&gt;&gt;1 表示将oldCapacity右移一位(位运算)，相当于除2。再加上1，相当于新容量扩容1.5倍。 如果newCapacity&gt;1=1,1&lt;2所以如果不处理该情况，扩容将不能正确完成。 如果新容量比最大值还要大，则将新容量赋值为VM要求最大值。 将elementData拷贝到一个新的容量中。 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } add(int index, E element)1.当添加数据是在首位插入时，先将新的数据放入到新的数组内，然后将原始数组中的数据复制到新的数组。2.当数据插入的位置是中间位置时，先将插入位置前面的数据先放到新的数组里，再放新的数据，再复制旧的数据完成添加。 3.数据尾部插入，由于不会影响其他元素，因此会直接插入到后面。 123456789public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;} rangeCheckForAdd()是越界异常检测方法。ensureCapacityInternal()之前有讲，着重说一下System.arrayCopy方法： 1234private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); set(int index,E element)覆盖旧值并返回。 1234567public E set(int index, E e) { rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue;} 异常检查 1234private void rangeCheck(int index) { if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));} 1234private void checkForComodification() { if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException();} 获取原值 123E elementData(int index) { return (E) elementData[index]; } 覆盖 1ArrayList.this.elementData[offset + index] = e; indexOf(Object o)比较简单 ，根据Object对象获取数组中的索引值。 如果o为空，则返回数组中第一个为空的索引；不为空也类似。 注意：通过源码可以看到，该方法是允许传空值进来的。 123456789101112public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1;} get(int index)返回指定下标处的元素的值。 rangeCheck(index)会检测index值是否合法，如果合法则返回索引对应的值。 12345public E get(int index) { rangeCheck(index); return elementData(index);} remove(int index)删除指定下标的元素。 1.从头部删除，删除头结点然后移动后面的数据，最后一个元素置空。2.从中间指定位置删除，找到要删除数据的位置，删除后，后面的数据移动，最后一个元素置空。 3.从尾部删除：直接删除尾部数据完成删除操作。 1234567891011121314public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 这么看下来其实ArrayList还不难，而且也是比较基础的东西，好好钻研吧，加油！ 我的博客：http://www.troubleq.com https://segmentfault.com/u/troubleq 作者参考：源码 + JAVA知音 网址：www.javazhiyin.com","link":"/2020/03/19/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9D%A2%E8%AF%95%E5%BF%85%E4%BC%9A/"},{"title":"重新启动IDEA时maven项目SSM框架文件变色所有@注解失效","text":"重新启动IDEA maven项目SSM框架所有@注解失效，每个文件上都有个小黄圆，而且我发现所有构建项目的maven的jar包都不在了，也就是说此时根本就不是一个maven项目了，这是IDEA的一个很烦人的bug，网上有很多解决的办法，我是这样解决的： Build -&gt; Rebuild Project 将项目进行重构 此时你会发现maven jar包重新导入进来 而文件异常是因为之前的文件标记消失了，重新标记 因为我这是SSM框架所以三个文件夹需要标记 右键各个文件 Mark Directory as -&gt; main.java —— Sources Root mian.resource —–Resources Root test.java —— Test Sources Root 恢复正常 结束，这个办法相当有效！","link":"/2020/03/22/%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8IDEA%E6%97%B6maven%E9%A1%B9%E7%9B%AESSM%E6%A1%86%E6%9E%B6%E6%96%87%E4%BB%B6%E5%8F%98%E8%89%B2%E6%89%80%E6%9C%89@%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88/"}],"tags":[],"categories":[]}